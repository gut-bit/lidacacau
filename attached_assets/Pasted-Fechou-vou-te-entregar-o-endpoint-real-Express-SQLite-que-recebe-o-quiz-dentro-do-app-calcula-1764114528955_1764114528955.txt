Fechou ‚Äî vou te entregar o endpoint real (Express + SQLite) que recebe o quiz dentro do app, calcula nota + XP no servidor (sem confiar no client), grava tentativas, atualiza XP total + n√≠vel da skill, e devolve o resultado pro front.

Abaixo vai tudo ‚Äúcopiar/colar‚Äù pro Replit.

1) Crie as tabelas de progresso (SQLite)

Crie o arquivo data/progress_schema.sql:

PRAGMA foreign_keys = ON;

CREATE TABLE IF NOT EXISTS users (
  id TEXT PRIMARY KEY,
  name TEXT,
  created_at TEXT DEFAULT (datetime('now'))
);

CREATE TABLE IF NOT EXISTS worker_skill (
  user_id TEXT NOT NULL,
  skill_id TEXT NOT NULL,
  xp_total INTEGER NOT NULL DEFAULT 0,
  level TEXT NOT NULL DEFAULT 'teaser',
  updated_at TEXT DEFAULT (datetime('now')),
  PRIMARY KEY (user_id, skill_id),
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS quiz_attempts (
  id TEXT PRIMARY KEY,
  quiz_id TEXT NOT NULL,
  user_id TEXT,
  os_id TEXT,
  total_questions INTEGER NOT NULL,
  correct_questions INTEGER NOT NULL,
  percent INTEGER NOT NULL,
  passed INTEGER NOT NULL,
  xp_calculated INTEGER NOT NULL,
  xp_awarded INTEGER NOT NULL,
  answers_json TEXT NOT NULL,
  created_at TEXT DEFAULT (datetime('now'))
);

CREATE INDEX IF NOT EXISTS idx_quiz_attempts_user_quiz ON quiz_attempts(user_id, quiz_id);

2) Coloque a defini√ß√£o do quiz (ta√ßa / poda circular) no backend

Crie content/quizzes/quiz_poda_limpeza_taca_circular_v1.json:

{
  "id": "quiz_poda_limpeza_taca_circular_v1",
  "skillId": "skill_poda_limpeza",
  "title": "Poda de Limpeza ‚Äì Poda Circular (Ta√ßa) | Quiz Final",
  "passPercent": 80,
  "xp": { "baseComplete": 50, "passBonus": 50, "maxScoreBonus": 40 },
  "questions": [
    {
      "prompt": "Qual formato de copa √© recomendado como arquitetura desej√°vel para o cacaueiro?",
      "choices": [
        "Cone (pontudo) para crescer alto",
        "Ta√ßa, com condu√ß√£o equilibrada dos ramos",
        "Uma ‚Äúparede‚Äù de ramos fechada, sem aberturas",
        "Qualquer formato serve, desde que corte bastante"
      ],
      "correctIndex": 1,
      "explanation": "Arquitetura desej√°vel em ta√ßa, com ramos conduzidos para equil√≠brio e boa capta√ß√£o de luz."
    },
    {
      "prompt": "No conceito de ta√ßa, o que significa ‚Äòequil√≠brio‚Äô de copa na pr√°tica?",
      "choices": [
        "Deixar um lado mais pesado para ‚Äòtombar‚Äô a planta para o sol",
        "Manter ramos principais em comprimentos parecidos, evitando desequil√≠brio quando carregar frutos",
        "Cortar todos os ramos secund√°rios e deixar s√≥ o tronco",
        "Abrir um buraco grande no topo para entrar sol direto"
      ],
      "correctIndex": 1
    },
    {
      "prompt": "A ‚Äòpoda circular‚Äô (Chico Duron/Dur√£o) tende a deixar a planta‚Ä¶",
      "choices": [
        "Mais alta e com copa fechada",
        "Mais baixa, com ramos mais grossos e formato de ta√ßa",
        "Totalmente sem sombra (pleno sol interno)",
        "Sem necessidade de remo√ß√£o de ramos internos"
      ],
      "correctIndex": 1
    },
    {
      "prompt": "Na poda de limpeza (manuten√ß√£o), qual alvo √© prioridade para preservar a ta√ßa?",
      "choices": [
        "Ramos para o centro da copa e ramos entrela√ßados/cruzados",
        "Somente folhas velhas",
        "Somente galhos muito grossos (sempre)",
        "Somente galhos externos (de fora para dentro)"
      ],
      "correctIndex": 0
    },
    {
      "prompt": "O que s√£o ‚Äòchup√µes‚Äô e por que entram na limpeza?",
      "choices": [
        "Ramos ortotr√≥picos muito vigorosos (base/caule) que drenam energia e bagun√ßam a arquitetura",
        "Frutos doentes presos ao tronco",
        "Um tipo de praga",
        "Folhas novas saud√°veis"
      ],
      "correctIndex": 0
    },
    {
      "prompt": "‚ÄòPalmas chupadeiras‚Äô s√£o melhor descritas como‚Ä¶",
      "choices": [
        "Ramos plagiotr√≥picos vigorosos, em geral pouco produtivos, que funcionam como dreno",
        "Ramos sempre produtivos que nunca devem ser cortados",
        "Somente ramos secos",
        "Ramos que d√£o flores direto no tronco"
      ],
      "correctIndex": 0
    },
    {
      "prompt": "Qual pr√°tica est√° alinhada com ‚Äòlimpeza‚Äô + ‚Äòta√ßa‚Äô (sem exagero)?",
      "choices": [
        "Abrir um ‚Äòclar√£o‚Äô de sol dentro da copa",
        "Eliminar ramos problema e manter a copa arejada sem buraco grande",
        "Cortar metade da copa em qualquer √©poca",
        "S√≥ cortar galhos altos para ‚Äòdar trabalho‚Äô mais r√°pido"
      ],
      "correctIndex": 1
    },
    {
      "prompt": "Na manuten√ß√£o/limpeza, al√©m de ramos, tamb√©m podem entrar como alvo‚Ä¶",
      "choices": [
        "Frutos secos e doentes",
        "Somente flores",
        "Somente ra√≠zes",
        "Somente tronco"
      ],
      "correctIndex": 0
    },
    {
      "prompt": "Qual √© o crit√©rio de ‚Äòcorte bom‚Äô?",
      "choices": [
        "Arrancar no bra√ßo para ganhar velocidade",
        "Corte limpo, sem rasgo e sem ferir o ramo principal/tronco",
        "Deixar toco longo para ‚Äòn√£o machucar‚Äô",
        "Cortar com l√¢mina cega para evitar corte ‚Äòprofundo‚Äô"
      ],
      "correctIndex": 1
    },
    {
      "prompt": "Por que evid√™ncias (fotos/checklist) e avalia√ß√£o p√≥s-servi√ßo s√£o parte do padr√£o do app?",
      "choices": [
        "S√≥ burocracia, sem impacto",
        "Tornam o servi√ßo audit√°vel, reduzem conflito e aumentam confian√ßa",
        "Substituem qualquer necessidade de orienta√ß√£o t√©cnica",
        "Servem apenas para punir o trabalhador"
      ],
      "correctIndex": 1
    }
  ]
}

3) Backend Express pronto (com c√°lculo de XP e n√≠vel)

Crie server.js na raiz do Replit:

const fs = require("fs");
const path = require("path");
const crypto = require("crypto");
const express = require("express");
const Database = require("better-sqlite3");

const DB_PATH = process.env.DB_PATH || "data/app.db";
const PROGRESS_SCHEMA = "data/progress_schema.sql";
const QUIZ_DIR = "content/quizzes";

const app = express();
app.use(express.json({ limit: "2mb" }));

function id() {
  return crypto.randomUUID ? crypto.randomUUID() : crypto.randomBytes(16).toString("hex");
}

function ensureDb(db) {
  if (fs.existsSync(PROGRESS_SCHEMA)) {
    db.exec(fs.readFileSync(PROGRESS_SCHEMA, "utf-8"));
  } else {
    console.warn("‚ö†Ô∏è progress_schema.sql n√£o encontrado em", PROGRESS_SCHEMA);
  }
}

function loadQuizDef(quizId) {
  const file = path.join(QUIZ_DIR, `${quizId}.json`);
  if (!fs.existsSync(file)) return null;
  return JSON.parse(fs.readFileSync(file, "utf-8"));
}

function getProgressionRule(db, skillId) {
  // usa tabela progression_rules do seed (se existir). fallback para n√≠veis m√≠nimos.
  const row = db.prepare("SELECT levels_json FROM progression_rules WHERE skill_id = ?").get(skillId);
  if (!row) {
    return [
      { level: "teaser", xp_required: 0 },
      { level: "N1_assistido", xp_required: 300 },
      { level: "N2_autonomo", xp_required: 900 },
      { level: "N3_mentoravel", xp_required: 2500 }
    ];
  }
  return JSON.parse(row.levels_json);
}

function computeLevel(levels, xpTotal) {
  // pega o maior level cujo xp_required <= xpTotal
  let current = levels[0]?.level || "teaser";
  for (const lv of levels) {
    if (typeof lv.xp_required === "number" && xpTotal >= lv.xp_required) current = lv.level;
  }
  return current;
}

function computeScore(quizDef, answers) {
  const total = quizDef.questions.length;
  let correct = 0;
  for (let i = 0; i < total; i++) {
    if (answers[i] === quizDef.questions[i].correctIndex) correct++;
  }
  const percent = Math.round((correct / total) * 100);
  const passPercent = quizDef.passPercent ?? 80;
  const passed = percent >= passPercent;
  return { total, correct, percent, passed, passPercent };
}

function computeXP(quizDef, percent, passed) {
  const passPercent = quizDef.passPercent ?? 80;
  const base = quizDef.xp?.baseComplete ?? 50;
  const passBonus = passed ? (quizDef.xp?.passBonus ?? 50) : 0;
  const maxBonus = quizDef.xp?.maxScoreBonus ?? 40;
  const bonus = Math.max(0, Math.min(maxBonus, Math.floor((percent - passPercent) * 2)));
  return base + passBonus + bonus;
}

// GET: para o app carregar o quiz pelo backend (opcional)
app.get("/api/quizzes/:id", (req, res) => {
  const quiz = loadQuizDef(req.params.id);
  if (!quiz) return res.status(404).json({ ok: false, error: "Quiz not found" });
  // manda sem gabarito se quiser (aqui manda tudo; MVP). Para produ√ß√£o: removia correctIndex.
  return res.json({ ok: true, quiz });
});

// POST: submiss√£o do quiz (servidor calcula score+xp)
app.post("/api/quizzes/submit", (req, res) => {
  const db = new Database(DB_PATH);
  try {
    ensureDb(db);

    const { quizId, userId, osId, answers } = req.body || {};
    if (!quizId || !Array.isArray(answers)) {
      return res.status(400).json({ ok: false, error: "quizId e answers[] s√£o obrigat√≥rios" });
    }

    const quizDef = loadQuizDef(quizId);
    if (!quizDef) return res.status(404).json({ ok: false, error: "Quiz definition not found in content/quizzes" });

    // valida tamanho
    if (answers.length !== quizDef.questions.length) {
      return res.status(400).json({
        ok: false,
        error: `answers[] precisa ter tamanho ${quizDef.questions.length}`
      });
    }

    // normalize answers
    const normalized = answers.map(a => Number.isInteger(a) ? a : parseInt(a, 10));
    if (normalized.some(a => Number.isNaN(a))) {
      return res.status(400).json({ ok: false, error: "answers[] deve conter √≠ndices num√©ricos" });
    }

    // garante usu√°rio (MVP)
    const safeUserId = userId || null;
    if (safeUserId) {
      db.prepare("INSERT OR IGNORE INTO users (id, name) VALUES (?, ?)").run(safeUserId, null);
    }

    const score = computeScore(quizDef, normalized);
    const xpCalculated = computeXP(quizDef, score.percent, score.passed);

    // regra anti-farm (MVP): s√≥ concede XP se bater o melhor XP anterior desse quiz
    let prevBestXp = 0;
    if (safeUserId) {
      const best = db.prepare(
        "SELECT MAX(xp_calculated) AS bestXp FROM quiz_attempts WHERE user_id = ? AND quiz_id = ?"
      ).get(safeUserId, quizId);
      prevBestXp = Number(best?.bestXp || 0);
    }
    const xpAwarded = safeUserId ? Math.max(0, xpCalculated - prevBestXp) : 0;

    const attemptId = id();
    db.prepare(`
      INSERT INTO quiz_attempts
      (id, quiz_id, user_id, os_id, total_questions, correct_questions, percent, passed, xp_calculated, xp_awarded, answers_json)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).run(
      attemptId, quizId, safeUserId, osId || null,
      score.total, score.correct, score.percent, score.passed ? 1 : 0,
      xpCalculated, xpAwarded, JSON.stringify(normalized)
    );

    // atualiza skill XP + level
    let xpTotal = null;
    let level = null;
    if (safeUserId) {
      const skillId = quizDef.skillId || "skill_poda_limpeza";

      const row = db.prepare(
        "SELECT xp_total FROM worker_skill WHERE user_id = ? AND skill_id = ?"
      ).get(safeUserId, skillId);

      const currentXp = Number(row?.xp_total || 0);
      xpTotal = currentXp + xpAwarded;

      const levels = getProgressionRule(db, skillId);
      level = computeLevel(levels, xpTotal);

      db.prepare(`
        INSERT INTO worker_skill (user_id, skill_id, xp_total, level)
        VALUES (?, ?, ?, ?)
        ON CONFLICT(user_id, skill_id) DO UPDATE SET
          xp_total = excluded.xp_total,
          level = excluded.level,
          updated_at = datetime('now')
      `).run(safeUserId, skillId, xpTotal, level);
    }

    return res.json({
      ok: true,
      attemptId,
      quizId,
      userId: safeUserId,
      osId: osId || null,
      score,
      xp: { calculated: xpCalculated, awarded: xpAwarded, total: xpTotal, level }
    });

  } catch (e) {
    console.error(e);
    return res.status(500).json({ ok:false, error: String(e) });
  } finally {
    db.close();
  }
});

const port = process.env.PORT || 3000;
app.listen(port, () => console.log("‚úÖ API on http://localhost:" + port));


Instale deps:

npm i express better-sqlite3

4) Ajuste o front do quiz (pra mandar s√≥ answers)

No seu HTML do quiz, troca a fun√ß√£o submitResultToBackend para:

async function submitResultToBackend({ answers }) {
  const userId = window.APP_USER_ID || "worker_demo_001"; // MVP
  const osId   = window.APP_OS_ID || null;

  const res = await fetch("/api/quizzes/submit", {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({
      quizId: QUIZ.id,
      userId,
      osId,
      answers
    })
  });
  return res.json();
}


E onde voc√™ chamava, use:

submitResultToBackend({ answers: state.answers })

5) Teste r√°pido (sem app inteiro)

Com o servidor rodando, manda um POST:

curl -X POST http://localhost:3000/api/quizzes/submit \
  -H "Content-Type: application/json" \
  -d '{"quizId":"quiz_poda_limpeza_taca_circular_v1","userId":"worker_demo_001","answers":[1,1,1,0,0,0,1,0,1,1]}'


Se voc√™ quiser, eu tamb√©m te entrego a tela ‚ÄúResultado‚Äù j√° puxando xp.total e xp.level do backend e mostrando:
‚úÖ ‚ÄúLiberou badge Teaser / N1 Assistido (pendente de OS)‚Äù + bot√£o ‚ÄúIr para Desafio de Campo‚Äù.

Voc√™ disse:
ok
O ChatGPT disse:

Fechado ü§ù

Pra voc√™ seguir agora sem dor de cabe√ßa, aqui vai o checklist m√≠nimo:

Criar data/progress_schema.sql (o SQL que te passei)

Criar content/quizzes/quiz_poda_limpeza_taca_circular_v1.json

Criar server.js

Rodar:

npm i express better-sqlite3
node server.js


No HTML do quiz, garantir que o fetch("/api/quizzes/submit") est√° enviando:

{ quizId: QUIZ.id, userId: "worker_demo_001", osId: null, answers: state.answers 